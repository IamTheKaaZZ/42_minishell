int
-  chdir(const char *path); returns 0 or -1 (errno)

  int
-  stat(const char *restrict path, struct stat *restrict buf);

  int
-  lstat(const char *restrict path, struct stat *restrict buf);

  int
-  fstat(int fildes, struct stat *buf);

	DIR *
-	opendir(const char *filename);

	struct dirent *
-	readdir(DIR *dirp);

	int
-	closedir(DIR *dirp);
error handling!!

--------------->[Ben's]<----------------------
bool	start_processes(void)
{
	t_exec	ex;
	int		i;

	if (!init_exec(&ex))
		return (false);
	i = ex.p_count;
	while (i--)
	{
		if (!open_infiles(&ex.proc[i]))
			return (false);
		if (!open_outfiles(&ex.proc[i]))
			return (false);
		if (!open_pipe(ex.pipe))
			return (err_handler("pipe"));
		ex.pid = fork();
		if (ex.pid < 0)
			return (err_handler("fork"));
		if (ex.pid == 0) //CHILD
		{
			if (ex.proc[i].last_out > 0)
			{
				dup2(ex.proc[i].last_out, STDOUT_FILENO);
				close(ex.proc[i].last_out);
			}
			else
				dup2(ex.prev_fd, STDOUT_FILENO);
			if (ex.proc[i].last_in.fd > 0)
			{
				dup2(ex.proc[i].last_in.fd, STDIN_FILENO);
				close(ex.proc[i].last_in.fd);
			}
			else
				dup2(ex.pipe[READ_END], STDIN_FILENO);
			close_pipe(ex.pipe);
			//check if it's a builtin
			ex.curr_envp = get_current_envp();
			if (execve(get_full_cmd_path(ex.proc[i].cmd_argv[0]), ex.proc[i].cmd_argv, ex.curr_envp) < 0)
				return (err_handler("execve"));
		} //PARENT
		reset_exec(&ex);
	}
	close_pipe(ex.pipe);
	while (wait(&ex.wstatus) > 0)
	{
		if (WIFEXITED(ex.wstatus) != true)
		{
			if (WEXITSTATUS(ex.wstatus) != EXIT_SUCCESS)
				err_handler("wait");
		}
	}
	return (true);
}
--------------->[Ben's]<----------------------



-------------->[Tony's stuff]<---------------

.h file:
// void	ft_echon(t_minishell *mini);
// void	ft_echo(void);
// void	ft_cd(t_minishell *mini);
// void	ft_pwd(t_minishell *mini);
// void	ft_export(t_minishell *mini);
// void	ft_unset(t_minishell *mini);
// void	ft_env(t_minishell *mini);
// void	ft_exit(t_minishell *mini);

minishell.c:
void	funstions()
{
	// if (mini->argv[0][0] == '$')
	// 	ft_dollar_sign(mini, 0); // working for argv[1];
	// if (!(ft_strncmp(g_mini.input, "echo -n", 7)))
	// 	ft_echon(&g_mini);
	// else if (!(ft_strncmp(g_mini.input, "echo", 4)))
	// 	ft_echo();
	// else if (!(ft_strncmp(mini->input, "cd", 2)))
	// 	ft_cd(mini);
	// else if (!(ft_strncmp(mini->input, "pwd", 3)))
	// 	ft_pwd(mini);
	// else if (!(ft_strncmp(mini->input, "export", 6)))
	// 	ft_export(mini);
	/*else if (!(ft_strncmp(mini->input, "unset", 5)))
		ft_unset(mini);*/
	// else if (!(ft_strncmp(mini->input, "env", 3)))
	// 	ft_env(mini);
	// else if (!(ft_strncmp(mini->input, "exit", 4)))
	// 	ft_exit(mini);
	// else
		executor(g_mini.argv);
}

minishell_builtins.c:
/*
 * All builtins set the exit_code to 2 on failure
*/




// void	ft_export(t_minishell *mini) // blad
// {
// 	t_list	*temp;

// 	temp = mini->env;
// 	ft_lstadd_back(&temp, ft_lstnew(ft_split(mini->argv[1], '=')));
// }

// void	ft_unset(t_minishell *mini) // co za kurwa gowno
// {
// 	t_list	*temp;
// 	t_list	*current;
// 	int		i;

// 	temp = mini->env;
// 	current = mini->env;
// 	i = 0;
// 	while (mini->argv[1])
// 		i++;
// 	while (temp)
// 	{
// 		if (!ft_strncmp(temp->next->keyword, mini->argv[1], i))
// 		{
// 			current = current->next;
// 			temp->next = current->next;
// 			free(current);
// 			current = NULL;
// 			break ;
// 		}
// 		temp = temp->next;
// 		current = current->next;
// 	}
// }

// void	ft_env(t_minishell *mini)
// {
// 	t_list	*temp;

// 	temp = mini->env;
// 	while (temp)
// 	{
// 		printf("%s%s\n", ft_strjoin(temp->keyword, "="), temp->content);
// 		temp = temp->next;
// 	}
// }

// void	ft_exit(t_minishell *mini)
// {
// 	(void)mini;
// 	ft_clear_data();
// 	exit(EXIT_SUCCESS);
// }

// void	ft_cd(t_minishell *mini)
// {
// 	if (chdir(mini->argv[1]) == -1)
// 	{
// 		err_handler("Builtin CD");
// 	}
// }

// void	ft_pwd(t_minishell *mini)
// {
// 	t_list	*temp;

// 	temp = mini->env;
// 	while (temp)
// 	{
// 		if (!ft_strncmp(temp->keyword, "PWD", 3))
// 		{
// 			ft_putstr_fd(temp->content, 1);
// 			break;
// 		}
// 		temp = temp->next;
// 	}
// }

// void	ft_echo(void)
// {
// 	int i;

// 	i = 0;
// 	while (g_mini.argv[++i])
// 	{
// 		printf("%s", g_mini.argv[i]);
// 		if (g_mini.argv[i + 1])
// 			printf(" ");
// 	}
// 	printf("\n");
// }

// void	ft_echon(t_minishell *mini)
// {
// 	int	i;

// 	i = 1;
// 	while (mini->argv[++i])
// 	{
// 		printf("%s", mini->argv[i]);
// 		if (mini->argv[i + 1])
// 			printf(" ");
// 	}
// 	printf("%%\n");
// }

// void	ft_interpret_input(void)
// {
// 	//scan through argv and act according to chars found
// }
